<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprPlayerIdle</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>parControl</parentName>
  <maskName>maskMain</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Variables



    //=====&gt;&gt; Movement variables &lt;&lt;================
    
        g_layer                 =   0;

        x_speed                 =   0;              // x speed
        top_x_speed             =   6;              // top x speed when running on flat ground
        max_x_speed             =   16;             // max x speed
        x_acceleration          =   0.046875;       // acceleration
        x_friction              =   x_acceleration;
        x_decceleration         =   0.5;            // deacceleration
        
        air_acceleration        =   x_acceleration*2;       // acceleration
        
        slope_decc_factor       =   0.152;           // slope deacceleration factor

        y_speed                 =   0;              // y speed
        max_y_speed             =   16;             // max y speed (only affects when going down)
        y_acceleration          =   0.2;            // y acceleration / gravity
        conversion_factor       =   0.8;            // speed conversion factor when landed on the ground
        
        jump_strenght           =   -6.25;          // the jump strenght        

        ground                  =   1;              // check wether the player is on the ground
        action                  =   0;              // determines the player current action
        angle                   =   0;              // current player angle
        
        
        anim_dir = 1;
        image_speed = 0;
        sprite_index = sprPlayerIdle;
        sprite_index_prev = sprPlayerIdle;
        image_index_prev = 0;
        anim_angle  = 0;
        anim_color = c_white;
        
        spin_power = 0;
        spin_spd = 0;
        spin_jump = false;
        
        invis   =   0;

       
    //=====&gt;&gt; Action tokens      &lt;&lt;================
        
        action_normal           =   0;              // used for making easier the comprehension of the engine
        action_jumping          =   1;
        action_spring_jumping   =   2;
        action_hurt             =   3;
        action_die              =   4;
        action_spin             =   5;
        
    //=====&gt;&gt; Input variables    &lt;&lt;================
        key_left                =   0;
        key_right               =   0;
        key_up                  =   0;
        key_down                =   0;
        key_action              =   0;
        key_dash_pressed        =   0;
        
        key_left_pressed        =   0;
        key_right_pressed       =   0;
        key_up_pressed          =   0;
        key_down_pressed        =   0;
        key_action_pressed      =   0;
        key_dash_pressed        =   0;
        
        assigned_key_left       =   vk_left;
        assigned_key_right      =   vk_right;
        assigned_key_up         =   vk_up;
        assigned_key_down       =   vk_down;
        assigned_key_action     =   ord("Z");
        assigned_key_dash       =   ord("X");


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
    // Extra stuff. Create a camera object, because if we plug the view object directly
    // to Sonic, it might get some strange tickering because of how it rounds the position
    // of the objects.
    
    shift = 0;
    camera_object = instance_create(x,y, objCamera);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Animation

if (ground) {

    if (angle &gt;= 37 &amp;&amp; angle &lt;= 323) {
        anim_angle = scr_player_rotate_towards(angle, anim_angle, max(6, abs(x_speed)));
    } else {
        anim_angle = 0;
    }
} else {
    if (anim_angle &gt; 0 &amp;&amp; anim_angle &lt; 180)
        anim_angle -= 2.5;
    else if (anim_angle &gt;= 180 &amp;&amp; anim_angle &lt; 360)
        anim_angle += 2.5;
}

if (anim_angle &lt; 0)
    anim_angle = 360 + anim_angle;

if (anim_angle &gt;= 360)
    anim_angle = 0;
    




if (action != action_hurt) {
    if (key_left) anim_dir = -1;
    else if (key_right) anim_dir = 1;
}

if (ground &amp;&amp; action == action_normal) {
    if (x_speed == 0) {
        sprite_index = sprPlayerIdle;
        image_speed = 0.05;
    } else if (abs(x_speed) &gt; 0 &amp;&amp; abs(x_speed) &lt; 6) {
        sprite_index = sprPlayerWalk;
        image_speed = 0.125 + abs(x_speed) / 24;
    } else {
        sprite_index = sprPlayerRun;
        image_speed = abs(x_speed) / 24;
    }
} else {
    if (action == action_jumping || action == action_normal) {
        sprite_index = sprPlayerJump;
        
        if (y_speed &lt; 0) image_speed = 0;
        else image_speed = 0.25;
    } else if (action == action_spring_jumping) {
        if (y_speed &lt; 0) {
            sprite_index = sprPlayerSpringJump;
            image_speed = abs(y_speed / 8);
            anim_angle = point_direction(xprevious, yprevious, x, y)-90;
        } else {
            sprite_index = sprPlayerJump; 
            image_speed = 0.25;
        }
    } else if (action == action_hurt) {
        sprite_index = sprPlayerHurt;
    } else if (action == action_die) {
        sprite_index = sprPlayerDie;
        anim_angle = point_direction(xprevious, yprevious, x, y)-90;
    } else if (action == action_spin) {
        sprite_index = sprPlayerSpin;
        image_speed = spin_spd/3;
    }
    
    if (sprite_index == sprPlayerJump) {
        if (image_index &gt;= 2) 
            image_speed = 0;
    }
    
}

if (sprite_index != sprite_index_prev)
    image_index = 0;
    

if (((sprite_index == sprPlayerWalk &amp;&amp; (floor(image_index) == 3 || floor(image_index) == 7)) ||
    (sprite_index == sprPlayerRun &amp;&amp; (floor(image_index) == 1))) &amp;&amp; 
    floor(image_index_prev) != floor(image_index)) {
    
    audio_play_sound(choose(sndGrass1,
                            sndGrass2,sndGrass3,sndGrass4,
                            sndGrass5,sndGrass6,sndGrass7,sndGrass8),
                     0, false);
    
}


if (abs(x_speed) &gt; 8 &amp;&amp; (global.game_tick mod 8 == 0)) {
    var sfx = instance_create(x, y, objSfxPlayerAfterimage);
    sfx.sprite_index  = sprite_index;
    sfx.image_index   = image_index;
    sfx.image_angle   = anim_angle;
    sfx.image_xscale  = anim_dir;
    sfx.image_speed   = 0;
}



sprite_index_prev = sprite_index;
image_index_prev = image_index;


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Extra stuff
    // Extra stuff. Set camera position to Sonic's position
    
    /*if (x_speed &gt;= 0)
        camera_object.x = floor(x) + max(camera_object.x - x, x_speed*4);
    else 
        camera_object.x = floor(x) + min(camera_object.x - x, x_speed*4);*/
        
    //camera_object.x = floor(x);
    //camera_object.y = floor(y);
    
    //camera_object.x = x;
    //camera_object.y = y;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Input data

    /* Get input data. Store them on variables for tracking them down
       easier :)
    */
    
    if (!instance_exists(objFadeGameIn)) {
    
    
        key_left    =   keyboard_check( assigned_key_left );
        key_right   =   keyboard_check( assigned_key_right );
        key_up      =   keyboard_check( assigned_key_up );
        key_down    =   keyboard_check( assigned_key_down );
        key_action  =   keyboard_check( assigned_key_action );
        key_dash    =   keyboard_check( assigned_key_dash );
        
        key_left_pressed    =   keyboard_check_pressed( assigned_key_left );
        key_right_pressed   =   keyboard_check_pressed( assigned_key_right );
        key_up_pressed      =   keyboard_check_pressed( assigned_key_up );
        key_down_pressed    =   keyboard_check_pressed( assigned_key_down );
        key_action_pressed  =   keyboard_check_pressed( assigned_key_action );
        key_dash_pressed    =   keyboard_check_pressed( assigned_key_dash );
    
    } else {
        key_left    =   0;
        key_right   =   0;
        key_up      =   0;
        key_down    =   0;
        key_action  =   0;
        key_dash    =   0;
        
        key_left_pressed    =   0;
        key_right_pressed   =   0;
        key_up_pressed      =   0;
        key_down_pressed    =   0;
        key_action_pressed  =   0;
        key_dash_pressed    =   0;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement control
    
    // ========== PART 1 ==============================================================================================        
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -&gt; X movement.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
           This is where we get the good stuff. We should move our player depending on
           our angle and in the x_speed.

           We're going to use, then again, trigonometry for calculating the new position of the player:
           The step, or the new position after rotating the character is

            x = x + cos(angle) * x_speed;
            y = y - sin (angle) * x_speed;

           or what it's the same:

            x += cos(angle) * x_speed;
            y -= sin(angle) * x_speed; 
        */
        
        if (action == action_die) {
            depth = -10000;
        
            y_speed += y_acceleration;
            y += y_speed;
        
            if (y &gt; view_yview+view_hview+64)
                instance_create(x,y,objFadeGameOver);
               
            
                
            exit;
        }
        
        x   +=  cos(degtorad(angle)) * x_speed;
        y   -=  sin(degtorad(angle)) * x_speed;
        
        if      (x &lt; 0)          {x = 0;          x_speed = 0;}
        else if (x &gt; room_width) {x = room_width; x_speed = 0;}
        
        if (camera_object.horizontal_lock) {
            if (x &lt; camera_object.x-200) {x = camera_object.x-200; x_speed = 0;}
            if (x &gt; camera_object.x+200) {x = camera_object.x+200; x_speed = 0;}    
        }

        /* And that's all. But now, you'll be thinking "but what now!? my character can go trough walls!!!".
           Now that we have the new position, we have to check if we're colliding within a wall, and if that
           is true, push the character to the outside until it doesn't collide anymore.
           There is when our sides collision functions enters on game:
           
           If the x_speed is going to one of the sides and that side is colliding, push the player
           in the oppsite direction until it isn't stuck anymore on the wall.
        */
            // move the player outside in case he has got stuck into the wall
            while (x_speed &gt; 0 &amp;&amp; player_collision_right( x, y, angle, maskMid ) == true )
            {
                x   -=  cos(degtorad(angle));
                y   +=  sin(degtorad(angle));
            }
            
            while (x_speed &lt; 0 &amp;&amp; player_collision_left( x, y, angle, maskMid ) == true )
            {
                x   +=  cos(degtorad(angle));
                y   -=  sin(degtorad(angle));
            }

    // ========== PART 2 ==============================================================================================        
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -&gt; Y movement.
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        This part is really easy. It's like your average static engine, so we don't need to apply any kind
        of trigonometry in this part. The first thing done here is to check if the player isn't on the ground
        (it's jumping, falling or whatever he's going). If that's the case, just move the player on Y axis
        &lt;y_speed&gt; times, so he goes up or down.
        */
        
        if (ground == false)
        {
            y   +=  y_speed;

            /* After this is done, player might get stuck, like how happened in the x movement. This problem
               can be easily fixed by doing the same routine. If the functions of collision are true,
               push the character until it doesn't collide */
               
                // move the player outside in case he has got stuck into the floor or the ceiling           
                while (y_speed &lt; 0 &amp;&amp; player_collision_top( x, y, 0, maskMid ) == true )
                {
                    y   +=  1;
                }            

                while (y_speed &gt; 0 &amp;&amp; player_collision_bottom( x, y, 0, maskMid ) == true )
                {
                    y   -=  1;
                }
                
            /* Now, this is a real essential part. This is used for check if the player now
               has landed on the ground. But as you might know, in Sonic games, y speed is converted
               in x speed when the character lands. So we should try to mimic it here too.
               
               When the player falls and the bottom sensor collides, check if the two side sensors
               are colliding with the ground. If the sides sensors are colliding then the char. landed 
               on a spot where there's no edge near, so calculate the angle of the floor. Otherwise, 
               just set the angle to 0.
               
               After that, we need to change the speed to a one relative to the X speed and the
               Y speed. Since the influence of the added Y speed is going to be based on the angle,
               just apply the sin (y projection as stated before) of the angle to the y_speed.
               
               After that, just set the y speed to 0, check if we need to change the actions again,
               and set the ground to true.
            */
                // check for landing
                if (y_speed &gt;= 0 &amp;&amp; player_collision_bottom( x, y, 0, maskBig ) == true)
                {
                    if ( player_collision_left_edge( x, y, 0 ) &amp;&amp; player_collision_right_edge( x, y, 0 ) )
                        angle   =   player_get_angle( x, y, 0 );
                    else
                        angle   =   0;
                        
                    x_speed -=  sin(degtorad(angle)) * y_speed;
                    y_speed =   0;
                    ground  =   true;
                    
                    // return to the normal state if the character was jumping
                    if (action == action_jumping || 
                        action == action_spring_jumping ||
                        action == action_hurt)
                    {                      
                        action = action_normal;
                        anim_color = c_white;
                        
                    }
                }
                
        /* Now, since the Y axys may have changed, we need to perfom again the wall collision to check
           if the player is now stuck from the sides. Just read above on how to do this */
            // wall collision (yeah, again, we should perform that since the y axys has recently changed)
            while (player_collision_right( x, y, angle, maskMid ) == true )
            {
                x   -=  cos(degtorad(angle));
                y   +=  sin(degtorad(angle));
            }
            
            while (player_collision_left( x, y, angle, maskMid ) == true )
            {
                x   +=  cos(degtorad(angle));
                y   -=  sin(degtorad(angle));
            }
        }

    // ========== PART 3 ==============================================================================================        
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -&gt; Slopes!
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
        This part isn't really hard. It uses the same concepts as a normal static engine, but
        with trigonometry. Our slopes routine works in a special way, we have a big circle mask
        (the main mask) wich is surrounded around with other ones. Two of those are the bottom
        sensor and the slopes sensor.
        
                    [crappy ASCII art warning!]
                          MMMMMMM
                        MMMMMMMMMMM
                       MMMMMMMMMMMMM           &lt;------- Main sensor
                       MMMMMMMMMMMMM
                        MMMMMMMMMMM
                          MMMMMMM
                          
                    -----------------------    &lt;------ Floor
                    
                           BBB
                          BBBBB                &lt;------ Bottom sensor
                           BBB
                           
                           SSS
                          SSSSS                &lt;------ Slopes sensor 
                           SSS
                    [crappy ASCII art warning!]
        
        When detecting and reacting on the slopes there can be two cases:
        
        A) First case. After we move the character we can see it keeps hovering above the
           slope since we only moved the character on the X axis. For preventing this we
           first need to check if the slopes sensor is collisioning within an obstacle while the main
           sensor isn't. If it is, push down until the main sensor collides.
           
        B) Second case. After we move the character, it gets stuck on the ground. That it's because
           there's a slope up. This is more simple to prevent, we only need to check if the main
           sensor is colliding the ground and if it is, push up! 

        Code wise it's really simple. We just apply the Y angle-based movement routine, wich is
        nearly the same as the X one. If for calculating the x projected/rotated positions is:
       
            rotated_x = x + cos( angle ) * distance;
            rotated_y = y - sin( angle ) * distance;
        
        The same for y projected/rotated position is:
            rotated_x = x + sin( angle ) * distance;
            rotated_y = y + cos( angle ) * distance;
        
        */
        
        if (ground == true)
        {
            if ( player_collision_main( x, y ) )
            {
                do
                {
                    x   -=  sin(degtorad(angle));
                    y   -=  cos(degtorad(angle));
                } until ( !player_collision_main( x, y ) )
            }
            if ( player_collision_slope( x, y, angle, maskMid ) &amp;&amp; !player_collision_main( x, y ) )
            {
                do
                {
                    x   +=  sin(degtorad(angle));
                    y   +=  cos(degtorad(angle));
                } until ( player_collision_main( x, y ) )
            }
        }

    // ========== PART 4 ==============================================================================================        
        /*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         -&gt; Other stuff
        ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        
        This part is just plain easy. We make fall the character if it isn't going at enough speed, or if the
        sides sensor aren't colliding. After that is done, if the character still remains on the floor, 
        get the new angle :)
        */
        
        // fall if there isn't enough speed
        if (angle &gt; 80 &amp;&amp; angle &lt; 280 &amp;&amp; ground == true &amp;&amp; abs(x_speed) &lt; 3)
        {
            y_speed =   -sin(degtorad(angle))*x_speed;
            x_speed =   cos(degtorad(angle))*x_speed;
            ground  =   false;
        }
        
        // fall off the ground if the edges aren't colliding
        if (ground == true &amp;&amp; angle != 0 &amp;&amp;
            (player_collision_left_edge( x, y, angle ) == false || player_collision_right_edge( x, y, angle ) == false  ))
        {
            y_speed =   -sin(degtorad(angle))*x_speed;
            x_speed =   cos(degtorad(angle))*x_speed;
            ground  =   false;
        }        
        
        // get new angle
        if (ground == true &amp;&amp; player_collision_left_edge( x, y, angle ) &amp;&amp; player_collision_right_edge( x, y, angle ))
        {
            angle   =   player_get_angle( x, y, angle );
        } else {
            angle   =   0;
        }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Gameplay   
     
    /* This is the basic gameplay code. I don't think it needs much explanation
       since it's all basic/logic stuff. If the player pushes the button,
       increase speed. If not, decrease.
       
       Also, if the player is on the ground, apply deacceleration depending
       on the angle.
       
       Check if the player is on the ground, and jump if the player presses
    */

    // gameplay
    
        //--------------------- x movement ---------------------
        
            if (action != action_hurt &amp;&amp; action != action_spin) {
                if (ground) {
                    if (key_left) {
                        if (x_speed &gt; 0) {
                            x_speed -= x_decceleration;
                            if (x_speed &lt;= 0)
                                x_speed = -0.5;                
                        } else if (x_speed &gt; -top_x_speed) {
                            x_speed -= x_acceleration;
                            if (x_speed &lt; -top_x_speed)
                                x_speed = -top_x_speed;
                        }
                    }
                    else if (key_right) {
                        if (x_speed &lt; 0) {
                            x_speed += x_decceleration;
                            if (x_speed &gt;= 0)
                                x_speed = 0.5;                
                        } else if (x_speed &lt; top_x_speed) {
                            x_speed += x_acceleration;
                            if (x_speed &gt; top_x_speed)
                                x_speed = top_x_speed;
                        }
                    } else {
                        x_speed -= min(abs(x_speed), x_friction) * sign(x_speed);
                    }
                } else {
                    if (key_left)       x_speed -= air_acceleration;
                    else if (key_right) x_speed += air_acceleration;
                }
            }
            
            if (y_speed &lt; 0 &amp;&amp; y_speed &gt; -4) {
                x_speed -= (floor(x_speed / 0.125) / 256);
            }

        
        // deacceleration on slopes
        if  (ground == true)
        {   
            if (angle &gt;= 22.5 &amp;&amp; angle &lt;= 337.5 )
                x_speed -=  sin(degtorad(angle)) * slope_decc_factor; //sin(degtorad(angle))
        }
        
        // full stop when we're colliding a wall
        if (x_speed &gt; 0 &amp;&amp; player_collision_right(x,y,angle,maskBig))
        {
            x_speed = 0;
        }
        if (x_speed &lt; 0 &amp;&amp; player_collision_left(x,y,angle,maskBig))
        {
            x_speed = 0;
        }        
        
        //--------------------- y movement ---------------------
        
        // check if the player is really on the ground
        if (ground == true &amp;&amp; player_collision_bottom(x,y,angle,maskBig) == false)
        {
            ground      = false;
            angle       = 0;
        }
        
        // check if for some reason the player has landed
        if (y_speed &gt;= 0 &amp;&amp; ground == false &amp;&amp; player_collision_bottom(x,y,angle,maskBig) == true)
        {
            ground      = true;
            y_speed     = 0;
                        
            // return to the normal state if the character was jumping
            if (action == action_jumping || 
                action == action_spring_jumping ||
                action == action_hurt)
            {
                anim_color = c_white;
                action = action_normal;
            }
        }
        
        // check if we're on the air but we collided with the ceiling
        if (y_speed &lt; 0 &amp;&amp; ground == false &amp;&amp; player_collision_top(x,y,angle,maskBig) == true)
        {
            y_speed     = 0;
        }
        
        // and finally, if we aren't on the ground, add the gravity to the y_speed
        if (ground == false)
        {
            y_speed  += y_acceleration;
            
            if (y_speed &gt; max_y_speed)
                y_speed = max_y_speed;
        }
        
        //--------------------- character actions ---------------------
        
        if (ground == true &amp;&amp; key_action_pressed &amp;&amp; action == action_normal)
        {
            // Jump
            y_speed     =   cos(degtorad(angle))*jump_strenght - sin(degtorad(angle))*x_speed;  // algorithm for a sonic-like
            x_speed     =   cos(degtorad(angle))*x_speed + sin(degtorad(angle))*jump_strenght;  // jump.
            
            ground      =   false;
            angle       =   0;
            
            action      =   action_jumping;
            
            audio_play_sound(sndJump, 0, false);
            
            spin_jump = false;
        }
        
        if (ground == false &amp;&amp; action == action_jumping &amp;&amp; !key_action) {
            if (y_speed &lt; -4) y_speed = -4;
        }
        
        if (invis &gt; 0)
            invis--;
        if (invis &lt; 0) {
            if (invis == -1) {
                audio_stop_sound(musPower);
                audio_play_sound(musZone1, 0, 0);
            }
            
            invis++;
        }
            
            
        if (action == action_spin) {
            if (key_dash) {
                if (global.plr_energy_power &gt; 0) {
                    spin_power++;
                    global.plr_energy_power--;
                }
                
                if (spin_power mod 49 == 0) {
                    spin_spd++;
                    instance_create(x, y, objSfxSpin);
                }
                    
            } else {
                
                action = action_normal;
                if (spin_power &gt; 4) {
                    if (!ground) {
                        y_speed = -(2 + spin_spd*2);
                    } else {
                        x_speed = (6 + spin_spd*2) * anim_dir;
                        camera_object.stop_timer = 15;
                    }
                }
            }
        } else if (((ground &amp;&amp; action == action_normal) || (!spin_jump &amp;&amp; action == action_jumping)) &amp;&amp; key_dash_pressed) { //action == action_normal &amp;&amp; ground &amp;&amp; abs(x_speed) &lt; 3 
            instance_create(x, y, objSfxSpin);
            if (global.plr_energy_power &gt; 0) {
                spin_jump = true;
                action = action_spin;
                x_speed /= 2;
                spin_power = 0;
                spin_spd = 1;
            }
        }
        
        
        
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle


if (place_meeting(x, y, objLayerSwitcher)) {
    if (x_speed &gt; 0) g_layer = 1;
    else if (x_speed &lt; 0) g_layer = 0;
}

if (place_meeting(x, y, objLayerLow)) g_layer = 0;
else if (place_meeting(x, y, objLayerHigh)) g_layer = 1;




var handle;

handle = player_collision_main_object(x, y, parEnemy);
if (handle) {
    
    if ((y_speed &gt; 0 &amp;&amp; !ground) || (invis &lt; 0)) {
        y_speed *= -1;
        audio_play_sound(sndSquish, 1, false);
        with handle instance_destroy();
    } else {
        player_take_damage();
    }    
}


var oHurt, oHurt2;
//oHurt = instance_nearest(x, y, parHurtable);
//oHurt2 = instance_nearest(x, y, parHurtableSolid);
if (player_collision_main_object(x, y, parHurtable) ||
    player_collision_main_object(x, y, parHurtableSolid)) {
        player_take_damage();  
}


handle = player_collision_bottom_object(x, y, 0, maskMain, objBubble);
if (handle &amp;&amp; y_speed &gt; 0) {
    with handle instance_destroy();
    y_speed *= -1;
}


handle = instance_nearest(x, y, objSpring);
if (handle) {
    if (!handle.activated &amp;&amp; player_collision_main_object(x, y, handle)) {
        
        audio_play_sound(sndSpring, 0, false);
    
       if (handle.image_angle != -90 &amp;&amp; handle.image_angle != 90)
            y_speed = -handle.spd * cos(degtorad(handle.image_angle));
       if (handle.image_angle != 0 &amp;&amp; handle.image_angle != 180)
            x_speed = -handle.spd * sin(degtorad(handle.image_angle));
       ground = false;
       
       action = action_spring_jumping;
       
       handle.image_index = 1;
       handle.image_speed = 0.125;
       
       handle.activated = true;
    } 
    
    if (!player_collision_main_object(x, y, handle)) {
        handle.activated = false;
    }
}


handle = instance_nearest(x, y, objBooster);
if (handle &amp;&amp; ground) {
    if (!handle.activated &amp;&amp; player_collision_main_object(x, y, handle)) {
        if (handle.image_xscale &gt; 0) {
            if (x_speed &lt; handle.spd)
                x_speed = handle.spd;
        } else {
            if (x_speed &gt; -handle.spd)
                x_speed = -handle.spd;
        }
        
        audio_play_sound(sndSpring, 0, false);
    
       handle.activated = true;
    } 
    
    if (!player_collision_main_object(x, y, handle)) {
        handle.activated = false;
    }
}


handle = player_collision_bottom_object(x, y, 0, maskMain, objZ1_movingPlatform);
if (ground &amp;&amp; handle) {
    x += handle.xsp;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>


    // draw (we should round the x and y values in order to prevent the "thikering")
    draw_sprite_ext(sprite_index,image_index,floor(x),floor(y), anim_dir, 1, anim_angle, anim_color, (!invis) || (global.game_tick % 12 &gt; 6));
      
    if (invis &lt; 0) {
        var _icolor = make_colour_hsv((global.game_tick*10) mod 255, 255, 255);
        
        draw_set_blend_mode(bm_add);
        draw_sprite_ext(sprite_index,image_index,floor(x),floor(y), anim_dir, 1, anim_angle, _icolor, 0.85);
        draw_set_blend_mode(bm_normal);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>223</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_current_room</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
